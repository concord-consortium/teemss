package org.concord.LabBook;import waba.util.*;import waba.ui.*;import extra.io.*;import org.concord.waba.extra.ui.*;import extra.ui.*;import extra.util.CCUnit;import org.concord.waba.extra.event.*;//LabObject implements Storablepublic class LObjImage extends LabObject{public LObjImageView view = null;    public LObjImage()    {		objectType = IMAGEOBJ;    }    public LabObjectView getView(LObjViewContainer vc, boolean edit,LObjDictionary curDict)    {    	 		if(view == null){    			view = new LObjImageView(vc, this, edit);    	}else if(view.container == null){    		view.container = vc;    		if(view.menu == null/* && edit*/){    			view.addMenus(vc);    		}    	}		return view;    }    public void writeExternal(DataStream out)    {		super.writeExternal(out);		if(view == null) return;		view.writeExternal(out);    }    public void readExternal(DataStream in)    {		super.readExternal(in);		if(view == null) view = new LObjImageView(null, this,false);		view.readExternal(in);    }    public boolean equals(TreeNode node){    	return super.equals(node);    }}class LObjImageView extends LabObjectView implements ActionListener{	Button clearButton,convertButton,doneButton,dirButton;	Choice catChoice;	Choice currChoiceFrom,currChoiceTo;	Edit	numberLeft,numberRight;	boolean leftToRight = true;    Menu menu = null;	ImagePane	imagePane = null;	private 	byte []bytes = null;	public LObjImageView(LObjViewContainer vc, LObjImage d,boolean edit){		super(vc);		if(edit) addMenus(vc);		lObj = d;		}	public void addMenus(LObjViewContainer vc){				if(menu != null || vc == null) return;		menu = new Menu("Image");		menu.add("Load Image ...");		menu.addActionListener(this);		vc.addMenu(this, menu);	}    public void onPaint(waba.fx.Graphics g){    	if(bytes != null && imagePane == null){			waba.fx.Image wabaImage = createImage(bytes);			if(wabaImage != null){				imagePane = new ImagePane(wabaImage);				add(imagePane);				imagePane.setRect(0,0);			}    	}    	super.onPaint(g);    }    public void writeExternal(DataStream out){  		if(bytes == null){    		out.writeBoolean(false); //error state			return;		}    	out.writeBoolean(true); //error state    	out.writeInt(1); //version    	out.writeInt(bytes.length);    	out.writeBytes(bytes,0,bytes.length);    }    public void readExternal(DataStream in){		bytes = null;   		if(!in.readBoolean()) return;		if(in.readInt() != 1) return; //I'm not ready yet for version 2		int bLength  = in.readInt();		if(bLength <= 0) return;						bytes = new byte[bLength];		in.readBytes(bytes,0,bLength);		    	if(imagePane != null){    		remove(imagePane);    	}     	imagePane = null;   }    public void layout(boolean sDone){		if(didLayout) return;		didLayout = true;		showDone = sDone;		if(showDone){			doneButton = new Button("Done");			add(doneButton);		}	}	public void setRect(int x, int y, int width, int height){		super.setRect(x,y,width,height);		if(!didLayout) layout(true);		if(doneButton != null){			doneButton.setRect(width/2 - 20, height - 17, 40, 15);		}	}    public void close(){		if(container != null && menu != null){		    container.delMenu(this,menu);		}		if(imagePane != null) imagePane.freeImage();		super.close();    }	public void onEvent(Event e){		if(e.target == doneButton &&			e.type == ControlEvent.PRESSED){			if(container != null){				container.done(this);			}			}	}    public void actionPerformed(ActionEvent e){		if(e.getActionCommand().equals("Load Image ...")){			openFileDialog();		}    }    public void openFileDialog(){    	String []extensions = {".bmp",".BMP"};    	FileDialog fd = FileDialog.getFileDialog(FileDialog.FILE_LOAD,extensions);    	if(fd == null) return;    	fd.show();    	bytes = fd.getBytesFromFile();    	if(bytes == null) return;    	if(imagePane != null){    		remove(imagePane);    	}		waba.fx.Image wabaImage = createImage(bytes);		if(wabaImage == null) return;		imagePane = new ImagePane(wabaImage);		add(imagePane);		imagePane.setRect(0,0);    	    }private static int inGetUInt32(byte bytes[], int off)	{	return ((bytes[off + 3]&0xFF) << 24) | ((bytes[off + 2]&0xFF) << 16) |		((bytes[off + 1]&0xFF) << 8) | (bytes[off]&0xFF);	}// Intel architecture getUInt16private static int inGetUInt16(byte bytes[], int off)	{	return ((bytes[off + 1]&0xFF) << 8) | (bytes[off]&0xFF);	}	private waba.fx.Image createImage(byte data[])	{	// read header (54 bytes)	// 0-1   magic chars 'BM'	// 2-5   uint32 filesize (not reliable)	// 6-7   uint16 0	// 8-9   uint16 0	// 10-13 uint32 bitmapOffset	// 14-17 uint32 info size	// 18-21 int32  width	// 22-25 int32  height	// 26-27 uint16 nplanes	// 28-29 uint16 bits per pixel	// 30-33 uint32 compression flag	// 34-37 uint32 image size in bytes	// 38-41 int32  biXPelsPerMeter (unused)	// 32-45 int32  biYPelsPerMeter (unused)	// 46-49 uint32 colors used (unused)	// 50-53 uint32 important color count (unused)	byte header[] = new byte[54];	int dataOffset = 0;	if (!waba.sys.Vm.copyArray(data,dataOffset,header,0,54))		{//		System.out.println("ERROR: can't read image header");		return null;		}	dataOffset += 54;	if (header[0] != 'B' || header[1] != 'M')		{//		System.out.println("ERROR:  is not a BMP image");		return null;		}	int bitmapOffset = inGetUInt32(header, 10);	int infoSize = inGetUInt32(header, 14);	if (infoSize != 40)		{//		System.out.println("ERROR:  is old-style BMP");		return null;		}	int width = inGetUInt32(header, 18);	int height = inGetUInt32(header, 22);	if (width < 0 || height < 0 || width > 65535 || height > 65535)		{//		System.out.println("ERROR:  has invalid width/height");		return null;		}	int bpp = inGetUInt16(header, 28);	if (bpp != 1 && bpp != 4 && bpp != 8)		{//		System.out.println("ERROR:  is not a 2, 16 or 256 color image");		return null;		}	int compression = inGetUInt32(header, 30);	if (compression != 0)		{//		System.out.println("ERROR:  is a compressed image");		return null;		}	int numColors = 1 << bpp;// it's wrong	int scanlen = (width * bpp + 7) / 8; // # bytes	scanlen = ((scanlen + 3) / 4) * 4; // end on 32 bit boundry	// read colormap	//	// 0-3 uint32 col[0]	// 4-7 uint32 col[1]	// ...	int cmapSize = bitmapOffset - 54;	byte cmapData[] = new byte[cmapSize];	if (!waba.sys.Vm.copyArray(data,dataOffset,cmapData,0,cmapSize))		{//		System.out.println("ERROR: can't read colormap");		return null;		}	dataOffset += cmapSize;//dima	numColors = cmapSize / 4; //4 is size of RGBQUAD structure//dima	int cmap[] = new int[numColors];	int j = 0;	for (int i = 0; i < numColors; i++)		{		byte blue = cmapData[j++];		byte green = cmapData[j++];		byte red = cmapData[j++];		j++; // skip reserved		cmap[i] = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);		}		byte pixels[] = new byte[scanlen*height];	int pixelOffset = pixels.length - scanlen;	do{		if (!waba.sys.Vm.copyArray(data,dataOffset,pixels,pixelOffset,scanlen)){			return null;		}		dataOffset += scanlen;		pixelOffset -= scanlen;	}while(pixelOffset >= 0);		waba.fx.Image wi = new waba.fx.Image(width,height);	if(wi != null) wi.setPixels(bpp,cmap,scanlen,height,0,pixels);	return wi;	}private void pixelsToRGB(int bitsPerPixel, int width, byte pixels[], int pixelOffset,	int rgb[], int rgbOffset, int cmap[])	{	int mask, step;	if (bitsPerPixel == 1)		{		mask = 0x1;		step = 1;		}	else if (bitsPerPixel == 4)		{		mask = 0x0F;		step = 4;		}	else // bitsPerPixel == 8		{		mask = 0xFF;		step = 8;		}	int bit = 8 - step;	int bytnum = pixelOffset;	int byt = pixels[bytnum++];	int x = 0;	while (true)		{		int colorIndex = ((mask << bit) & byt) >> bit;		rgb[rgbOffset++] = cmap[colorIndex] | (0xFF << 24);		if (++x >= width)			break;		if (bit == 0)			{			bit = 8 - step;			byt = pixels[bytnum++];			}		else			bit -= step;		}	}}