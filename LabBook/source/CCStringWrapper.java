package org.concord.LabBook;import org.concord.waba.extra.ui.*;import org.concord.waba.extra.event.*;import waba.ui.*;import waba.fx.*;import waba.sys.*;import waba.util.Vector;import extra.io.*;public class CCStringWrapper{String str;CCTextArea owner = null;int  	beginPos 	= 5;int		endPos 		= 50;int		beginRow	= -1;int		endRow		= -1;char 	[]chars = null;int		delimiters[] = null;static int	[]charWidthMappers = null;int		rColor = 0;int		gColor = 0;int		bColor = 0;boolean		link 		= false;int			indexInDict = -1;	CCStringWrapper(CCTextArea owner,String str,int beginRow){		this.str = str;		init(owner, beginRow);	}	CCStringWrapper(DataStream in){		str = in.readString();		if(str == null) str = "";		link = in.readBoolean();		rColor = in.readByte() & 0xFF;		gColor = in.readByte() & 0xFF;		bColor = in.readByte() & 0xFF;		indexInDict = in.readInt();	}	public void init(CCTextArea owner, int beginRow)	{		this.owner = owner;		if(owner != null){			Rect r = owner.getRect();			beginPos 	= r.x + owner.insetLeft;			endPos 		= r.x + r.width - owner.insetRight;			setStr(str,beginRow);		}			}		public void writeExternal(DataStream out){		out.writeString(str);		out.writeBoolean(link);		out.writeByte((byte)rColor);		out.writeByte((byte)gColor);		out.writeByte((byte)bColor);		out.writeInt(indexInDict);	}	private static void createCharWidthMappers(CCTextArea owner){		if(charWidthMappers != null || owner == null) return;		FontMetrics fm = owner.getFontMetrics();		if(fm == null) return;		charWidthMappers = new int[96];		for(int i = 0; i < 96; i++){			charWidthMappers[i] = fm.getCharWidth((char)(i+32));		}	}		String getStr(){return str;}	void setStr(String str,int beginRow){		this.beginRow 	= beginRow;		if(owner == null){			this.str = null;			return;		}				if(str == null) str = "";		int    numbTotalRows = (owner.rows == null)?0:owner.rows.getCount();						this.str = str;		FontMetrics fm = owner.getFontMetrics();		if(fm == null || str == null) return;		int currRow = beginRow;		int x 			= (currRow >= numbTotalRows || owner.rows == null)?beginPos:((CCTARow)owner.rows.get(currRow)).beginPos;		int lastWord 	= 0;		int	blankWidth = fm.getCharWidth(' ');		int	delimiterIndex = 0;		int i = 0;				int nLines = 0;		delimiters = null;		chars = str.toCharArray();		while(i < str.length()){			char c = str.charAt(i);			if(isWordDelimiter(c)){				if(c == '\n') break;				lastWord = i+1;			}			if(charWidthMappers == null){				createCharWidthMappers(owner);			}			int w = 0;			if(c >= ' ' && c < (char)128){				w = (charWidthMappers != null)?charWidthMappers[(int)c - 32]:fm.getCharWidth(c);			}else{				w = fm.getCharWidth(c);			}									int limitX = (currRow >= numbTotalRows || owner.rows == null)?endPos:((CCTARow)owner.rows.get(currRow)).endPos;									if(x + w > limitX){				if(lastWord == delimiterIndex){					lastWord = i;				}else{					i = lastWord;				}				int nInt = 0;				if(delimiters != null){					nInt = delimiters.length;				}				int	[]newDelimiters = new int[nInt + 2];				if(delimiters != null){					waba.sys.Vm.copyArray(delimiters,0,newDelimiters,0,nInt);				}				delimiters = newDelimiters;				delimiters[nInt] = delimiterIndex;				delimiters[nInt+1] = lastWord;								currRow++;				x = (currRow >= numbTotalRows || owner.rows == null)?beginPos:((CCTARow)owner.rows.get(currRow)).beginPos;												delimiterIndex = i;			}else{				x += w;			}			i++;		}		if(delimiters == null){			delimiters = new int[2];			delimiters[0] = 0;			delimiters[1] = chars.length;		}else{			if(delimiterIndex < str.length()){				int nInt = delimiters.length;				int	[]newDelimiters = new int[nInt + 2];				waba.sys.Vm.copyArray(delimiters,0,newDelimiters,0,nInt);				delimiters = newDelimiters;				delimiters[nInt] = delimiterIndex;				delimiters[nInt+1] = chars.length;			}		}		this.endRow 	= this.beginRow + (delimiters.length / 2);	}		public int getRows(){		return (endRow - beginRow);	}		String getFullStr(){		return str;	}		public void setMargins(int beginPos,int endPos){		this.beginPos 	= beginPos;		this.endPos 	= endPos;	}	public void setRows(int beginRow,int endRow){		this.beginRow 	= beginRow;		this.endRow 	= endRow;	}		public String getSubString(int index){		if(chars == null || delimiters == null) return null;		if(index < 0 || index >= delimiters.length / 2) return null;		return new String(chars,delimiters[2*index],delimiters[2*index+1]-delimiters[2*index]);	}		public void draw(Graphics gr,int firstRow){		if(gr == null || delimiters == null || owner == null) return;		int    numbTotalRows = (owner.rows == null)?0:owner.rows.getCount();		int h = owner.getItemHeight();		int limitRow = delimiters.length / 2;		gr.setColor(rColor,gColor,bColor);		for(int i = beginRow; i < endRow; i++){			if(i < firstRow) continue;			int y = CCTextArea.yTextBegin + (i - firstRow)*h;			if(i - beginRow < limitRow ){				int x = (i >= numbTotalRows || owner.rows == null)?beginPos:((CCTARow)owner.rows.get(i)).beginPos;				int index = (i - beginRow)*2;				gr.drawText(chars,delimiters[index],delimiters[index+1] - delimiters[index],x,y);				if(link){					int xEnd = x;					FontMetrics fm = owner.getFontMetrics();					int lineY = h - 2;					if(fm != null){						xEnd = x + fm.getTextWidth(chars,delimiters[index],delimiters[index+1] - delimiters[index]);						lineY = fm.getHeight()+1;					}else{						xEnd = (i >= numbTotalRows || owner.rows == null)?endPos:((CCTARow)owner.rows.get(i)).endPos;					}					if(xEnd > x) gr.drawLine(x,y + lineY,xEnd,y + lineY);				}			}		}		gr.setColor(0,0,0);	}	public static boolean isWordDelimiter(char c){		boolean retValue = false;		for(int i = 0; i < wordDelimChars.length; i++){			if(c == wordDelimChars[i]){				retValue = true;				break;			}		}/*		switch(c){			case ' ':			case '\t':			case ';':			case '.':			case ',':				retValue = true;				break;		}*/		return retValue;	}	private static char []wordDelimChars = {' ','\t',';','.',',','/','\\'};	}